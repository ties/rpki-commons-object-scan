/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package net.ripe.objectscan

import io.github.oshai.kotlinlogging.KotlinLogging
import net.ripe.rpki.commons.crypto.x509cert.X509ResourceCertificateParser
import net.ripe.rpki.commons.validation.ValidationCheck
import net.ripe.rpki.commons.validation.ValidationMessage
import net.ripe.rpki.commons.validation.ValidationResult
import java.io.File
import java.io.IOException
import java.lang.IllegalStateException
import java.nio.file.FileSystems
import java.nio.file.Files
import java.nio.file.Path
import java.util.concurrent.locks.Lock
import java.util.concurrent.locks.ReentrantLock
import java.util.function.Predicate
import java.util.stream.Collectors
import java.util.stream.Stream
import kotlin.concurrent.withLock
import kotlin.io.path.extension
import kotlin.io.path.isDirectory
import kotlin.io.path.name
import kotlin.streams.asStream
import kotlin.system.exitProcess

private val logger = KotlinLogging.logger {}


class App(val base: String){
    val basePath = File(base).toPath()

    val lock = ReentrantLock()

    fun parseFile(path: Path): Stream<Pair<String, ValidationCheck>> {
        try {
            var validationResult = ValidationResult.withLocation(path.toUri());
            X509ResourceCertificateParser.parseCertificate(validationResult, Files.readAllBytes(path))

            return Stream.concat(
                    validationResult.failuresForAllLocations.map { failure ->
                        Pair(path.name, failure)
                    }.stream(),
                    validationResult.warnings.map { warning ->
                        Pair(path.name, warning)
                    }.stream()
            )
        } catch (ex: Exception) {
            logger.error("Exception parsing {}: {}", path, ex)
        }

        return Stream.empty()
    }

    fun run() {
        val paths = basePath.toFile().walkTopDown()
                .asStream()
                .map(File::toPath)
                .filter(Predicate.not(Path::isDirectory))
                .filter { it.extension.equals("cer") }
                .collect(Collectors.toList())

        logger.info("Gathered {} files.", paths.size)

        val failures = paths.parallelStream()
                .flatMap(this::parseFile)
                .collect(Collectors.toList())
        logger.info("Finished processing.")

        failures.groupBy { failedObject -> failedObject.second.key }.forEach() { (failedCheckType, failedChecksAndNames) ->
            logger.info("level: {} check: {}", failedChecksAndNames.get(0).second.status, failedCheckType)
            failedChecksAndNames.forEach { elem ->
                logger.info("  * {}", elem.first)
            }
        }
    }
}

fun main(args: Array<String>) {
    if (args.size < 1) {
       logger.error("Please pass a path as argument.")
        exitProcess(1)
    }
    logger.info("Scanning {}", args[0])
    App(args[0]).run()
    exitProcess(0)
}
